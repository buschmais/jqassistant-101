:imagesdir: includes

= Getting started with jQAssistant and Domain Driven Design
Stephan Pirnbaum <stephan.pirnbaum@buschmais.com>

:numbered:

[.lead]
// tag::lead[]
Demonstrates how to map DDD concepts in the code to the graph and apply constraints using the DDD plugin,
// end::lead[]

NOTE: This tutorial has been written for jQAssistant 1.8.0

== Prerequisites

- Any Java application which implements (or shall implement) DDD concepts

== Overview

The DDD for jQAssistant plugin provides the ability to map well-known DDD concepts to the source code and finally to the generated graph.
Based on this, it allows to define and verify DDD-specific constraints.

Detected violations will be printed as warnings at the end of the build or might even break it if required.

The steps in this tutorial illustrate:

- Setup of the <<MavenProject>>
- Checking the <<PreDefinedRules>>
- Using the <<PreDefinedConcepts>>
- Using the <<PreDefinedConstraints>>
- Using the <<StrictGroup>>
- Definition of <<ProjectSpecificRules>>

[[MavenProject]]
== jQAssistant DDD Plugin

jQAssistant runs as part of the build process and therefore needs to be integrated as Maven plugin.
This is done by adding the following setup to the `build/plugins` section of the file `pom.xml`:

[source,xml]
.pom.xml
----
include::pom.xml[tag=plugin,indent=0]
----

The configuration above...

- activates the goals `scan` and `analyze` during a build
- adds the jQAssistant DDD plugin
- activated the java-ddd:Default profile

Furthermore, to make use of the provided annotations, the DDD annotations must be added as maven dependency to the project as shown below.
[source,xml]
.pom.xml
----
include::pom.xml[tag=dependency,indent=0]
----

The Maven build can be triggered as usual on the command line:

----
mvn clean install
----

[[PreDefinedRules]]
== Pre-Defined Rules

The setup above activates the pre-defined group `java-ddd:Default` that provides some basic constraints for
the structure and architecture of the project.

You can execute the goal `effective-rules` on the command line using

----
mvn jqassistant:effective-rules
----

to print a summary of all currently active rules and a short description for each of them.

[[PreDefinedConcepts]]
== Pre-Defined Concepts

The DDD plugin comes with pre-defined jQAssistant concepts.
For each DDD concept, there is a mapping on type and package level.

With that, you can either declare all classes in a package (and its sub-packages) as, e.g. part of a bounded context as shown below.

[source,java]
.src/main/java/your/company/project/order/package-info.java
----
include::src/main/java/your/company/project/order/package-info.java[]
----

Or directly by annotating a specific Java class as shown next.

[source,java]
.src/main/java/your/company/project/order/OrderService.java
----
include::src/main/java/your/company/project/order/OrderService.java[tags=dddType]
----

[[PreDefinedConstraints]]
== Pre-Defined Constraints

The DDD plugin comes with a set of pre-defined constraints checking the most basic architecture violations possible.
Following things will be checked during build time:


- `java-ddd:IllegalDependenciesBetweenBoundedContexts`
-- If there are dependencies between layers which were not defined
- `java-ddd:UnneededDependenciesBetweenBoundedContexts`
-- If there are dependencies between bounded contexts defined which are actually not used
- `java-ddd:TypeInMultipleBoundedContexts`
-- If there are types assigned to multiple bounded contexts
- `java-ddd:IllegalDependenciesBetweenBoundedContexts`
-- If there are dependencies between bounded contexts which were not defined

[[StrictGroup]]
== java-ddd:Strict Group

Additionally to the `java-ddd:Default` group, the DDD plug-in comes with another, more strict group called `java-ddd:Strict`.

This group can be activated via the following configuration in the `pom.xml` as shown below.

[source,xml]
----
<configuration>
    <groups>
        <group>java-ddd:Strict</group>
    </groups>
</configuration>
----

Following concept will be provided:

- `java-ddd:DefinedLayerDependencies`
-- Adds `DEFINES_DEPENDENCY` relations between Layer nodes based on the allowed directions mentioned by Eric Evans

Following constraint will be checked:
- `java-ddd:IllegalDependenciesBetweenTechnicalLayers`
-- If there are dependencies between layers implemented which are not allowed

[[ProjectSpecificRules]]
== Project Specific Rules

The concepts defined by the DDD plugin are also a good base for project specific rules.
This is especially true as the plugin comes only with a few, relaxed constraints.

There are two use cases imaginable for the DDD plugin

1. A given application shall be refactored to match a DDD-like structure.
This refactoring has to take place during daily development and in small steps as continuous improvement steps.
The DDD plugin will be used to track and secure the improvements.

2. A new application shall be implemented with a DDD-like structure.
The DDD plugin will be used from start on to verify that the designed architecture is actually implemented.

Depending on the state of the application, it is possible to define additional, more or less strict constraints. e.g that only aggregate roots may be accessible through repositories.

The rules must be located in `/jqassistant` and can be written either in XML or Asciidoc files, where the latter approach is recommended.

The following examples will be defined in the file `jqassistant/architecutre.adoc`:

.jqassistant/architecture.adoc
....
include::jqassistant/architecture.adoc[tag=group,indent=0]
....

It defines a group `architecture:Default` which must be activated in the `pom.xml` file (see pom in section <<MavenProject>> above).
This group contains all constraints and concepts matching the definition.

=== Adding DDD Constraints

Besides the group definition, the example defines that repositories are allowed to only return aggregates which will be checked by

- the constraint `architecture:AggregateRepository` that ensures that only DDD aggregates (i.e. classes annotated with
`@DDD.Aggregate`) are returned by repositories (i.e. classes annotated with `@DDD.Repository`)

.Aggregate constraint definition as defined in jqassistant/architecture.adoc
....
include::jqassistant/architecture.adoc[tag=aggregates]
....

The project can be built and verified by running the following command:

----
mvn clean install
----

=== Visualization of Building Blocks

As shown earlier, the plugin comes with annotations for identifying technical layers and bounded contexts in the source code.

The current structure of the application can, when using those annotations (i.e. `@DDD.BoundedContext` and `@DDD.Layer.<classifier>Layer`)
be easily visualized by automatically generated plantuml diagrams.

The generation of the component diagrams will be accomplished by the added jQAssistant AsciiDoc Report plugin.

An example to visualize the defined bounded contexts including their defined and actual dependencies is shown in the following listing.
It defines:

* the concept `architecture:BoundedContextOverview` that identifies all defined bounded contexts and their dependencies

.Bounded Context overview as defined in jqassistant/architecture.adoc
....
include::jqassistant/architecture.adoc[tag=boundedcontexts]
....

Finally the group `architecture:Default` must be activated in the `pom.xml` file (see pom in section <<MavenProject>> above).

The project can be built and verified by running the following command:

----
mvn clean install
----

The resulting component diagram will look as follows:

image::architecture_BoundedContextOverview.svg[]

== Resources

1. link:tutorial.zip[ZIP archive including the application]
2. https://jqassistant.github.io/jqassistant/doc/1.6.0/index.html#_concepts_and_constraints_provided_by_the_spring_plugin[jQAssistant Spring Plugin documentation]
3. https://maven.apache.org[Apache Maven]
